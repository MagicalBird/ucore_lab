# Lab6 report

计34 2011011384 郑玉昆

## 练习0：填写已有实验

对alloc_proc()中增加对新增变量的初始化。具体如下：

```C
proc->rq = NULL;
list_init(&(proc->run_link));
proc->time_slice = 0;
proc->lab6_run_pool.left=proc->lab6_run_pool.right=proc->lab6_run_pool.parent=NULL;
proc->lab6_stride = 0;
proc->lab6_priority = 0;
```

## 练习1: 使用 Round Robin 调度算法

- 请理解并分析sched_class中各个函数指针的用法，并接合Round Robin 调度算法描ucore的调度执行过程

  - void (*init)(struct run_queue *rq)：对等待队列进行初始化操作。

  - void (*enqueue)(struct run_queue *rq, struct proc_struct *proc)：将某一个进程放入到队列中。
 
  - void (*dequeue)(struct run_queue *rq, struct proc_struct *proc)：让某一个进程出队。
 
  - struct proc_struct *(*pick_next)(struct run_queue *rq)：进程选取，这里选择的不同进程表示了不同了调度算法。
 
  - void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc)：对于时钟进行响应和处理。对于时间片用完的情况进行处理。

  - ucore的调度执行过程
    当运行到一个内核抢占点或者时间片用完时，ucore会进行调度，主要的实现参见schedule()函数，它会将当前进程入队，然后选择下一个进程，将该进程出队，进行进程切换。

- 请在实验报告中简要说明如何设计实现”多级反馈队列调度算法“，给出概要设计，鼓励给出详细设计



## 练习2: 实现 Stride Scheduling 调度算法

首先需要换掉RR调度器的实现，即用default_sched_stride_c覆盖default_sched.c。然后根据此文件和后续文档对Stride度器的相关描述，完成Stride调度算法的实现。

后面的实验文档部分给出了Stride调度算法的大体描述。这里给出Stride调度算法的一些相关的资料（目前网上中文的资料比较欠缺）。

strid-shed paper location1
strid-shed paper location2
也可GOOGLE “Stride Scheduling” 来查找相关资料
执行：make grade。如果所显示的应用程序检测都输出ok，则基本正确。如果只是priority.c过不去，可执行 make run-priority 命令来单独调试它。大致执行结果可看附录。（ 使用的是 qemu-1.0.1 ）。

请在实验报告中简要说明你的设计实现过程。



# 练习一
## 使用 Round Robin 调度算法

#### 请理解并分析sched_class中各个函数指针的用法，并接合Round Robin 调度算法描ucore的调度执行过程。

对于sched_class中的各个函数类都采用了函数指针来实现，并且使用的是RR调度算法的实现。
- void (*init)(struct run_queue *rq); 对等待队列进行初始化操作。
- void (*enqueue)(struct run_queue *rq, struct proc_struct *proc); 将某一个进程放入到队列中。
- void (*dequeue)(struct run_queue *rq, struct proc_struct *proc); 让某一个进程出队。
- struct proc_struct *(*pick_next)(struct run_queue *rq); 进程选取，这里选择的不同进程表示了不同了调度算法。
- void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc); 对于时钟进行响应和处理。对于时间片用完的情况进行处理。



#### 请在实验报告中简要说明如何设计实现”多级反馈队列调度算法“，给出概要设计，鼓励给出详细设计。

在当前的进程控制块中，设置多个队列，每个队列对应不同的时间片长度，以及设置一个变量，表示当前运行进程所在的队列Q。

enqueue

- 新产生的进程入队时，进入Q1队列进行等待。
- 如果当前进程因为时间片用完而进行调度，假设当前进程所在的队列为Q，那么将其加入到下一个队列中。

pick_next

- 在进行进程调度时，优先从Q1队列按照FIFO方式进行选择，然后再依次从后续队列中进行选择。

dequeue

出队操作并无不同，只是简单将pick_next选择的进程出队。

proc_tick

在进行处理时，需要根据当前进程所在队列Q设置的相应的时间进行处理。

# 练习二
## 实现 Stride Scheduling 调度算法

通过对于实验框架的理解，替换掉之前的RR调度算法，使用了链表和skew_heap对进行了实现。每个函数的实现如下：


#### strid_init函数
```
static voidstride_init(struct run_queue *rq) {     /* LAB6: 2012011394      * (1) init the ready process list: rq->run_list      * (2) init the run pool: rq->lab6_run_pool      * (3) set number of process: rq->proc_num to 0      */	list_init(&(rq->run_list));	rq->lab6_run_pool = NULL;	rq->proc_num = 0;}
```
进行初始化操作，按要求进行即可。

#### enqueue

```
static voidstride_enqueue(struct run_queue *rq, struct proc_struct *proc) {     /* LAB6: 2012011394      * (1) insert the proc into rq correctly      * NOTICE: you can use skew_heap or list. Important functions      *         skew_heap_insert: insert a entry into skew_heap      *         list_add_before: insert  a entry into the last of list      * (2) recalculate proc->time_slice      * (3) set proc->rq pointer to rq      * (4) increase rq->proc_num      */#if USE_SKEW_HEAP	rq->lab6_run_pool = skew_heap_insert(rq->lab6_run_pool, &(proc->lab6_run_pool), proc_stride_comp_f);#else	list_add_before(&(rq->run_list), &(proc->run_link));#endif	if (proc->time_slice == 0 || proc->time_slice > rq->max_time_slice)			proc->time_slice = rq->max_time_slice;	proc->rq = rq;	rq->proc_num ++;}
```
如果使用堆时，采用skew_heap_insert函数进行插入操作，采用链表时使用list_add_before进行插入操作。

更新入队进程所需要占用的时间片。

设置proc的rq变量，增加进程数。

#### dequeue

```
static voidstride_dequeue(struct run_queue *rq, struct proc_struct *proc) {     /* LAB6: 2012011394      * (1) remove the proc from rq correctly      * NOTICE: you can use skew_heap or list. Important functions      *         skew_heap_remove: remove a entry from skew_heap      *         list_del_init: remove a entry from the  list      */#if USE_SKEW_HEAP	rq->lab6_run_pool = skew_heap_remove(rq->lab6_run_pool, &(proc->lab6_run_pool), proc_stride_comp_f );#else	list_del_init(&(proc->run_link));#endif	rq->proc_num --;}
```
两种方法分别使用skew_heap_remove和list_del_init方法进行删除。

#### pick_next

```
static struct proc_struct *stride_pick_next(struct run_queue *rq) {     /* LAB6: 2012011394      * (1) get a  proc_struct pointer p  with the minimum value of stride             (1.1) If using skew_heap, we can use le2proc get the p from rq->lab6_run_poll             (1.2) If using list, we have to search list to find the p with minimum stride value      * (2) update p;s stride value: p->lab6_stride      * (3) return p      */#if USE_SKEW_HEAP	if (rq->lab6_run_pool == NULL) return NULL;	struct proc_struct *p = le2proc(rq->lab6_run_pool, lab6_run_pool);#else	struct proc_struct *p = le2proc(&(rq->run_list), run_link);	list_entry_t* next = &rq->run_list;	if (next == list_next(next))		return NULL;	while ((next = list_next(next)) != &rq->run_list){		struct proc_struct *q = le2proc(next, run_link);		if (q->stride < p->stride)			p = q;	}#endif	if (p->lab6_priority == 0)		p->lab6_stride += BIG_STRIDE;	else p->lab6_stride += BIG_STRIDE / p->lab6_priority;	return p;}
```

这是调度算法的核心，使用堆时，堆顶元素即为最小值。采用链表的话需要便历练表才能找到最小值。

找到之后根据该进程的priority对步长stride进行增加。

#### proc_tick

```
static voidstride_proc_tick(struct run_queue *rq, struct proc_struct *proc) {     /* LAB6: 2012011394 */	if (proc->time_slice > 0){		proc->time_slice --;	} else if (proc->time_slice == 0) {		proc->need_resched = 1;	}}
```
对于时间片进行处理，每次时钟中断时减一，值为0时则进行相关调度。



